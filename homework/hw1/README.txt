作业说明：

0.作业截止时间：4月2日（周日23:59），作业提交方式：教学网

1. 环境要求：

	【C++】 11及以上，推荐g++编译器
	【Python】 3.7及以上

2. 常用命令：

	【C++编译】
		g++ [文件名].cpp -o [输出文件名] --std=c++11 -O3

	【执行Python脚本】
		python [文件名].py

	【将输出重定向到文件】
		./[可执行文件名] > [输出目标文件名]
	
	【观察进程占用设备资源情况】
		Linux/MacOS:	top
		Windows任务管理器:	taskmgr

3. 样例代码：

	样例代码有C++和Python两个版本，两个版本实现逻辑一致，文件层次结构一致，均提供了必要的注释辅助理解。
	
	C++/Python的代码目录下包含4个文件夹：algorithm, interface, problem, utils.
	【interface】
		包括其余文件夹下代码所依赖的状态StateBase接口，定义了搜索求解问题的状态表示方法。
	【algorithm】
		包括DFS, BFS, UCS和Heuristic search的实现，这些算法实现依赖StateBase接口提供的调用；
	【problem】
		包括n皇后问题和最短路径问题的状态建模，这些状态建模实现了StateBase接口；
	【utils】
		包括其余文件夹下代码依赖的工具方法与工具类。

	代码目录下包含 queen_bfs_dfs.cpp/.py ，可编译/执行该文件，使用DFS/BFS求解八皇后问题所有解。
	代码目录下包含 short_path_ucs.cpp/.py，可编译/执行该文件，使用UCS求解最短路径问题的一个解。

4. 任务描述
	
	【n皇后问题】
		运行n皇后问题的C++/Python代码，比较两种语言实现的深搜与广搜在皇后数为8-15时的时间与空间消耗，填写实验报告中的表格。			
		要求：
			1.填写使用/不使用IO情况下广度优先搜索11/12皇后问题时间统计表，体会IO产生的时间开销。关闭IO的方法见提示。
			2.填写运行时间的表格，表项时间单位为 秒，此时需要关闭IO。
			3.填写空间消耗的表格，表项空间单位为 个状态，此时需要关闭IO。
		提示：
			1.调用dfs/bfs的search方法时，传入参数为(true, false)，因为八皇后环境的实现是逐行填子，无重复状态，是树搜索，并且也不需要记录路径。
			2.将算法文件中search方法的show_reversed_path(last_state_of, state) 和 state.show()注释掉，即可关闭IO。
			3.统计时间消耗，以秒为单位，如果运行时间超过5分钟，可提前终止进程，并在时间统计表中标注">300"，空间统计表中标注"/"。
			4.若某种设定（程序设计语言/算法/使用IO情况）下某个问题的运行超过5分钟，则不需运行该设定下更大规模的问题求解程序，且表项填写方式同上。
			5.统计空间消耗，只需填写搜索使用的栈/队列在运行时的峰值大小，即含有的最大状态个数（代码中已经实现，会在C++代码运行结束时输出）。

	【最短路径问题】
		利用C++/Python代码中给出的接口，构建有向图，求解课件第34页城市Arad到Bucharest的最短距离（cpp/python代码中已经给出了地点名称的列表以及各条边的信息，以便建图使用）
		要求：
			1.使用一致代价搜索（已经实现在uniform_cost_search中，注意传入的状态价值估计为 -已经走过的路程，即-state.cumulative_cost() ）、
				贪心搜索、A*搜索（贪心的状态价值估计为 -到目标结点直线距离，A*的状态价值估计取 -(已经走过的路程+到目标结点直线距离)）分别运行求解。
			2.输出上述三种算法各个节点进入优先队列的顺序，找到的路径以及路径长度 ，将运行结果截屏放入实验报告中。
			3.除将上述三种算法各个节点进入优先队列的顺序、找到的路径、路径长度运行结果截图放在报告中展示外，还应当将其总结在报告表格中（只需要写顶点编号）。
		提示：
			1. 该作业可以选择基于C++版本实现或是基于Python版本实现，不需要在两个版本上各实现一次。但是推荐不熟悉其中一种语言的同学都尝试一遍。
			2. 向HeuriticSearch::search中传入启发式函数的实现方式可以参考UniformCostSearch的实现。
			3. 对于DirectedGraphState的对象state来说，state.cumulative_cost()已经记录了从起点到当前点走过路径的总花费，这正是UniformCostSearch对状态估值的依据。
			4. 输出路径可以参考utils/show_path.hpp中的show_reversed_path.
			

5. 补充材料：
	【Python官方文档】
		https://docs.python.org/zh-cn/3/



