hw1：作业一是全局搜索算法。 原版作业见homework1_original，任务要求见 hw1/README.txt 分N皇后和最短路径问题。
运行环境：
C++是程序在Ubuntu18.04，gcc9.4.0运行（本身是7.5.0但hsc师兄顺便就配好了）。python是在Ubuntu18.04,python3.8运行（本来都想在ubuntu18.04运行，但ubuntu18.04自带7.5.0版的gcc报错，貌似gcc8以上版本才OK）。

N皇后问题：
python/c++都需要运行，但都直接写好了，注释输出、点个运行就可以（hw1/python/queens_bfs_dfs.py），比较宽度优先、广度优先搜索时间空间就行。
最短路径问题：
我用的python版本。要求完成一致代价搜索（已经实现在hw1/python/algorithm/uniform_cost_search.py）、贪心搜索、A*搜索

N皇后搜索问题建模：
每行为树的一层，上一层有N个位置作为节点，向下发展，广搜即先探索完上一层的状态（可放置的位置），再向下，直到最后一行valid或者已经不行即切断。valid的路径就输出。

评价：皇后问题没什么意思，浪费时间整理。

最短路径问题：
比较一致代价（dijkstra）、贪心、A*搜索算法在罗马尼亚寻径问题（见.png）的效果。
只运行python，读代码要花点时间，总之估值是负的g或h或g+h，越大越好，稍微修改代码即可。

hw2：作业二是局部搜索算法，相比全局搜索，通过启发函数加速搜索，时间复杂度大大减小，但不保证一定搜到解。
运行环境： 很坑，为了作业统一标准，要求必须用C++，我习惯python。
还是N皇后问题。
爬山法：
分三个选择方式 第一更优选择、最大估值选择和轮盘赌选择。
状态估值函数h(n)=1/(n^conflicts数)，要求值达到1，也就是conflicts为0才停。（当然有找不到更优后继状态而失败，直接重启就是了）
模拟退火：
爬山+随机游走（等概率向周围邻居移动，增加探索）：通过温度值来控制往估值差状态探索的概率，刚开始温度高，探索概率大，跳出局部极值；随着时间推移，温度下降，探索概率小，达到最优。
t=1/n*exp(n-t/16/n)（当然可以也自己设置）  选择状态时更优或者探索概率exp-(|d|/t) 就跳转了
